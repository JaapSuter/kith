// Generated by CoffeeScript 1.3.3
var FS, HOME, Path, Utils, alignLeft, betterStack, color, env, formatHtml, formatText, handleUncaughtExceptions, htmlEscape, injectSourceLines;

FS = require("fs");

HOME = process.env.HOME;

Path = require("path");

Utils = require("./utils");

env = process.env.NODE_ENV || "development";

color = function(s) {
  return s;
};

alignLeft = function(lines) {
  var i, left, line, result, _i, _j, _k, _len, _len1, _ref, _results;
  result = [];
  left = Number.MAX_VALUE;
  for (_i = 0, _len = lines.length; _i < _len; _i++) {
    line = lines[_i];
    line.code = Utils.tabToSpaces(line.code);
    for (i = _j = 0, _ref = line.code.length; 0 <= _ref ? _j < _ref : _j > _ref; i = 0 <= _ref ? ++_j : --_j) {
      if (line.code[i] !== " ") {
        left = Math.min(left, i);
      }
    }
  }
  _results = [];
  for (_k = 0, _len1 = lines.length; _k < _len1; _k++) {
    line = lines[_k];
    _results.push(line.code = line.code.slice(left));
  }
  return _results;
};

/*
Gets original source line and injects into stack.

@param {Array} lines Array of lines from stack.
@param {String} fileName The file being tested.


@returns [
  {
    frame: 'stack line', code: [
      { linenum: 123, code: 'compiled line'},
      { linenum: 124, code: 'compiled line'},
      { linenum: 125, code: 'compiled line', isErrorLine: true},
      { linenum: 126, code: 'compiled line'},
      { linenum: 127, code: 'compiled line'},
    ]
  },
  {
    frame: 'stack line', code: [
      { linenum: 123, code: 'compiled line'},
      { linenum: 124, code: 'compiled line'},
      { linenum: 125, code: 'compiled line', isErrorLine: true},
      { linenum: 126, code: 'compiled line'},
      { linenum: 127, code: 'compiled line'},
    ]
  }
]
*/


injectSourceLines = function(lines, fileName, contextLinesCount) {
  var buffer, cache, codeFile, coffee, col, collectSource, ext, i, lineObj, linenum, matches, newLines, pushLine, re, text;
  newLines = [];
  collectSource = true;
  cache = {};
  i = 1;
  while (i < lines.length) {
    lineObj = {
      frame: lines[i],
      code: []
    };
    newLines.push(lineObj);
    if (collectSource) {
      re = /(~[^:]+):(\d+):(\d+)/;
      matches = re.exec(lines[i]);
      if (matches) {
        codeFile = matches[1];
        codeFile = codeFile.replace("~", HOME);
        linenum = parseInt(matches[2]);
        col = matches[3];
        ext = Path.extname(codeFile);
        pushLine = function(text, suffix) {
          var j, textLines;
          suffix = suffix || "";
          textLines = text.split("\n");
          j = 0;
          while (j < textLines.length) {
            if (j >= (linenum - 1 - contextLinesCount) && (j < linenum - 1)) {
              lineObj.code.push({
                linenum: j + 1,
                code: textLines[j]
              });
            } else if (j === linenum - 1) {
              lineObj.code.push({
                linenum: j + 1,
                code: textLines[j],
                isErrorLine: true
              });
              if (!(contextLinesCount > 0)) {
                break;
              }
            } else if ((j > linenum - 1) && (j < linenum + contextLinesCount)) {
              lineObj.code.push({
                linenum: j + 1,
                code: textLines[j]
              });
              if (j === (linenum - 1 + contextLinesCount)) {
                break;
              }
            }
            j++;
          }
          return alignLeft(lineObj.code);
        };
        try {
          if (ext === ".js") {
            text = cache[codeFile];
            if (!text) {
              text = FS.readFileSync(codeFile, "utf8");
              cache[codeFile] = text;
            }
            pushLine(text);
          } else if (ext === ".coffee") {
            text = cache[codeFile];
            if (!text) {
              coffee = require("coffee-script");
              buffer = FS.readFileSync(codeFile, "utf8");
              text = coffee.compile(buffer, {});
              cache[codeFile] = text;
            }
            pushLine(text);
          }
        } catch (err) {
          console.log(err.stack);
        }
      }
    }
    i++;
  }
  return newLines;
};

/*
Removes nodeunit specic line trace from stack and colors any
line from current test module.

@param {String} stack Error stack.
@param {Object} mod The test module.
@returns {String} Returns the modified stack trace.
*/


betterStack = function(stack, contextLinesCount, fileName) {
  var i, line, lines, result;
  if (fileName == null) {
    fileName = 'foo';
  }
  lines = stack.split("\n");
  result = [];
  i = 0;
  while (i < lines.length) {
    line = lines[i];
    if (i === 0) {
      line = "  " + line;
    } else {
      if (line.indexOf(fileName) >= 0) {
        line = color(line, "white+b");
      } else {
        if (line.indexOf(HOME) < 0) {
          line = color(line, "black+b");
        }
      }
    }
    result.push(line.replace(HOME, "~"));
    i += 1;
  }
  return result = injectSourceLines(result, fileName, contextLinesCount);
};

formatText = function(frames) {
  var frame, line, result, _i, _j, _len, _len1, _ref, _ref1;
  if (!frames) {
    return "";
  }
  result = "";
  for (_i = 0, _len = frames.length; _i < _len; _i++) {
    frame = frames[_i];
    result += frame.frame + "\n";
    if (((_ref = frame.code) != null ? _ref.length : void 0) > 0) {
      _ref1 = frame.code;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        line = _ref1[_j];
        result += "        " + (Utils.padLeft(line.linenum.toString(), 4)) + ": " + line.code + "\n";
      }
    }
  }
  return result;
};

formatHtml = function(frames) {
  var attr, frame, line, result, _i, _j, _len, _len1, _ref, _ref1;
  if (!frames) {
    return "";
  }
  result = "<ul>";
  for (_i = 0, _len = frames.length; _i < _len; _i++) {
    frame = frames[_i];
    result += "<li>";
    result += "  <div class='frame'>" + htmlEscape(frame.frame) + "</div>";
    if (((_ref = frame.code) != null ? _ref.length : void 0) > 0) {
      result += "  <ul class='source'>";
      _ref1 = frame.code;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        line = _ref1[_j];
        attr = line.isErrorLine ? "class='error-line'" : "";
        result += "  <li " + attr + ">";
        result += "<pre>" + Utils.padLeft(line.linenum.toString(), 4) + ": " + htmlEscape(line.code) + "</pre>";
        result += "  </li>";
      }
      result += "  </ul>";
    }
    result += "</li>";
  }
  return result += "</ul>";
};

handleUncaughtExceptions = function() {
  return process.on("uncaughtException", function(err) {
    var message, stack;
    message = err;
    stack = "";
    if (err.stack) {
      stack = formatText(betterStack(err.stack, contextLinesCount));
    }
    return console.error("Uncaught exception", "" + err.message + "\n" + stack);
  });
};

exports.express3 = function(options) {
  var contextLinesCount, dumpExceptions, enableUncaughtExceptions, showStack;
  if (options == null) {
    options = {};
  }
  showStack = options.showStack || false;
  dumpExceptions = options.dumpExceptions || false;
  enableUncaughtExceptions = options.enableUncaughtExceptions || false;
  contextLinesCount = options.contextLinesCount || 0;
  if (enableUncaughtExceptions) {
    handleUncaughtExceptions();
  }
  return function(err, req, res, next) {
    var accept, error, json, prop, stack;
    if (err.status) {
      res.statusCode = err.status;
    }
    if (res.statusCode < 400) {
      res.statusCode = 500;
    }
    accept = req.headers.accept || "";
    stack = betterStack(err.stack, contextLinesCount);
    if (env === "development") {
      console.error(formatText(stack));
    }
    if (~accept.indexOf("html")) {
      return FS.readFile(__dirname + "/../public/style.css", "utf8", function(e, style) {
        return FS.readFile(__dirname + "/../public/error.html", "utf8", function(e, html) {
          stack = formatHtml(stack);
          html = html.replace("{style}", style).replace("{stack}", stack).replace("{title}", exports.title).replace("{statusCode}", res.statusCode).replace(/\{error\}/g, htmlEscape(err.toString()));
          res.setHeader("Content-Type", "text/html; charset=utf-8");
          return res.end(html);
        });
      });
    } else if (~accept.indexOf("json")) {
      error = {
        message: err.message,
        stack: stack
      };
      for (prop in err) {
        error[prop] = err[prop];
      }
      json = JSON.stringify({
        error: error
      });
      res.setHeader("Content-Type", "application/json");
      return res.end(json);
    } else {
      res.writeHead(res.statusCode, {
        "Content-Type": "text/plain"
      });
      return res.end(stack);
    }
  };
};

htmlEscape = function(s) {
  return String(s).replace(/&(?!\w+;)/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
};

exports.title = "express-error";
